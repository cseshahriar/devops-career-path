# Access Django container shell
docker compose exec web bash

# Run migrations
docker compose exec web python manage.py migrate

# Create superuser
docker compose exec web python manage.py createsuperuser

# Access PostgreSQL from host (using psql)
psql -h localhost -p 5433 -U docker_user -d mydjangodb

docker compose logs -f	View container logs
docker compose restart web	Restart Django

# Build and Run
docker compose build

docker ps

# Start Containers
docker compose up

# build and up
docker compose up --build
docker compose run web python manage.py collectstatic

docker compose down -v  # ⚠️ Destroys all volumes, including db data!

# run 
docker run -d -p 8080:8080 --name my_django_container docker-django-web

-d runs the container in detached mode (background).
-p 8080:8080 maps port 8080 on your local machine to port 8080 inside the container (assuming your Django app runs on port 8000).
--name my_django_container names your container for easy reference.
- docker-django-web is the image name.
- docker rm my_django_container

# access container
docker exec -it my_django_container /bin/bash


# Stop Containers
docker compose down
docker compose down -v # Stops containers but retains database volume

# for production
command: gunicorn --bind 0.0.0.0:8000 your_project.wsgi:application

List Docker images:
docker images

List Docker containers:
docker ps
docker ps -a  # To list all containers, including stopped ones

docker logs <container_name_or_id>
docker inspect <container_name_or_id>

# remove images 
docker rmi <image_name_or_id> 
docker rmi <image_name_or_id_1> <image_name_or_id_2>

i.e docker rmi myimage:latest
i.e docker rmi myimage:latest another_image:tag

# remove all
docker rmi $(docker images -q)

# remove container
docker stop <container_name_or_id>
docker rm <container_name_or_id>
docker container prune
